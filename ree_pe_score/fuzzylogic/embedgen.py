from datetime import datetime

from .fuzzylogic import FuzzyRule
from .fuzzycurves import get_propdetails_for_obj
from .settings import load_settings

INDENT_STEP=' '*3

def _write_header(indent,buff,flimport):
    subIndent=indent+INDENT_STEP
    buff.write(f'"""\n{subIndent}Generated by NETL\'s fuzzylogic package on {datetime.today()}.\n')
    buff.write(f'\n{subIndent}NOTE: This is an automated file; do not edit directly!!!\n"""\n\n')

    # write imports
    buff.write(f'from {flimport} import FuzzyRule,FuzzyInput,FuzzyResult,FLCombiner,NoDataSentinel,FuzzyNoValError\nfrom {flimport}.fuzzycurves import *\n\n')
    buff.write('NODATA_VAL=-99999.\n\n')

def _write_check(indent,buff,names):
    buff.write(f'{indent}def recordMissingKeys(indict):\n')
    indent+=INDENT_STEP
    buff.write(f'{indent}ret=[]\n')

    for var in names:
        buff.write(f'{indent}if \'{var}\' not in indict:\n')
        buff.write(f'{indent+INDENT_STEP}ret.append(\'{var}\')\n')
    buff.write(f'{indent}return ret\n\n')

def _write_input(indent,buff,input,varname='input',typename='FuzzyInput'):

    buff.write(f'{indent}{varname}={typename}("{input.name}",{input.minval},{input.maxval})\n')
    for _,c in input.curve_iter():
        buff.write(f'{indent}curve={c.__class__.__name__}("{c.name}")\n')
        props = get_propdetails_for_obj(c)
        for pe in props:
            buff.write(f'{indent}curve.{pe.prop}={getattr(c,pe.prop)}\n')
        buff.write(f'{indent}{varname}.add_curve(curve)\n')

def _write_flset(indent,buff,key,fls,varname='fls'):

    buff.write(f'{indent}{key}_inputs = {{}}\n')
    for inp in fls.inputs:
        _write_input(indent,buff,inp)
        buff.write(f'{indent}{key}_inputs[input.name]=input\n')
    _write_result(indent,buff,fls.result)
    # buff.write(f'{indent}results = result\n')
    buff.write(f'{indent}{varname} = {{"_inputs":{key}_inputs,"_result":result}}\n')


def _write_result(indent,buff,result):
    _write_input(indent,buff,result,'result','FuzzyResult')

def _write_rule_set(indent,buff,rules,varName):

    buff.write(f'{indent}def _run_{varName}(inVals,_inputs,_result):\n')
    indent+=INDENT_STEP
    for rule in rules:
        buff.write(f'{indent}return {rule.pythonlogic}\n\n')

def _write_run_code(indent,buff,flsets):

    buff.write(f'{indent}def get_implications(_flsets,inVals):\n')
    indent+=INDENT_STEP
    buff.write(f'{indent}_impls={{}}\n')

    for name in flsets.keys():
        buff.write(f'{indent}try:\n')
        buff.write(f'{indent+INDENT_STEP}_impls["{name}"]=_run_{name}(inVals,**_flsets["{name}"])\n')
        buff.write(f'{indent}except FuzzyNoValError as err:\n')
        buff.write(f'{indent + INDENT_STEP}_impls["{name}"]=err\n')
    # buff.write(f'{indent}for i in range(1,len(_impls)):\n')
    # buff.write(f'{indent+INDENT_STEP}_impls[0]+=_impls[i]\n')
    buff.write(f'{indent}return _impls\n\n')


def _write_combiners(indent,buff,combiners):

    buff.write(f'{indent}def apply_combiners(_impls,_combiners,addl_args=None):\n')
    indent+=INDENT_STEP
    buff.write(f'{indent}_ret={{}}\n')
    for name,combo in combiners.items():
        buff.write(f'{indent}try:\n')
        buff.write(f'{indent+INDENT_STEP}_ret["{name}"]=_combiners["{name}"].evaluate(_impls,addl_args)\n')
        buff.write(f'{indent}except FuzzyNoValError:\n')
        buff.write(f'{indent+INDENT_STEP}_ret["{name}"]=NODATA_VAL\n')
    buff.write(f'{indent}return _ret\n\n')

def _write_nodata_mode(indent,buff,ndVal,ndMethod,ndSubValue):

    buff.write(f'{indent}def gen_nodata_sentinel():\n')
    indent+=INDENT_STEP
    buff.write(f'{indent}# derived from Nodata method: {ndMethod}\n')
    buff.write(f'{indent}ret=NoDataSentinel()\n')
    buff.write(f'{indent}ret.ignore={ndMethod=="ignore"}\n')
    buff.write(f'{indent}ret.subVal={None if ndMethod!="substitute" else ndSubValue}\n')
    buff.write(f'{indent}return ret\n\n')

def generate_embeddable(buff,infile,flimport):
    settings=load_settings(infile)

    _write_header('',buff,flimport)
    # collect expected arguments and import rules
    # go through the sets and grab input names
    inNames=set()
    for fls in settings['fuzzyLogicSets'].values():
        fls.import_rules()

        for inp in fls.inputs:
            inNames.add(inp.name)

    _write_check('',buff,inNames)

    buff.write('def initialize():\n')
    buff.write(f'{INDENT_STEP}_flsets={{}}\n')
    for name,fls in settings['fuzzyLogicSets'].items():
        _write_flset(INDENT_STEP,buff,name,fls,f'_flsets["{name}"]')

    buff.write(f'{INDENT_STEP}_combiners={{}}\n')
    for name,combo in settings['fuzzyLogicCombiners'].items():
        buff.write(f'{INDENT_STEP}_combiners["{name}"]=FLCombiner("""{combo["combineStatement"]}""",'
                   f'"{combo["defaultDefuzzOperator"]}",defuzzDict={combo["defuzzOperators"]})\n')
    buff.write(f'{INDENT_STEP}return _flsets,_combiners\n\n')

    _write_nodata_mode('',buff,settings['noVal'],settings['noDataMethod'],settings['noDataSubValue'])

    for name,fls in settings['fuzzyLogicSets'].items():
        _write_rule_set('',buff,fls.rules,name)
    _write_run_code('',buff,settings['fuzzyLogicSets'])
    _write_combiners('',buff,settings['fuzzyLogicCombiners'])
