"""Take fuzzylogic statements and generate an embeddable python module for use in larger projects.
The generated module will still expect the fuzzylogic package to be discoverable.
"""

from datetime import datetime

from .fuzzylogic import PiecewiseCurve, FuzzyRule
from .combiner import FLCombiner
from .fuzzycurves import get_propdetails_for_obj
from .settings import load_settings

INDENT_STEP = ' '*3


def _write_header(indent, buff, flimport='fuzzylogic'):
    """Write header information to buffer.

    Args:
        indent (str): Whitespace indicating indent level.
        buff (Filelike): Buffer being written to.
        flimport (str,optional): package name to stand in for `fuzzylogic`.
    """

    subindent = indent+INDENT_STEP
    buff.write(f'"""\n{subindent}Generated by NETL\'s fuzzylogic package on {datetime.today()}.\n')
    buff.write(f'\n{subindent}NOTE: This is an automated file; do not edit directly!!!\n"""\n\n')

    # write imports
    buff.write(f'from {flimport} import FuzzyRule,FuzzyInput,FuzzyResult,FLCombiner,NoDataSentinel,'
               f'FuzzyNoValError\nfrom {flimport}.fuzzycurves import *\n\n')

    buff.write('NODATA_VAL=-99999.\n\n')


def _write_check(indent, buff, names):
    """Write function to check for the availability of the provided keys within the intended input dictionary.

    Args:
        indent (str): Whitespace indicating indent level.
        buff (Filelike): Buffer being written to.
        names (list): String of variables to detect.
    """

    buff.write(f'{indent}def recordMissingKeys(indict):\n')
    indent += INDENT_STEP
    buff.write(f'{indent}ret=[]\n')

    for var in names:
        buff.write(f'{indent}if \'{var}\' not in indict:\n')
        buff.write(f'{indent+INDENT_STEP}ret.append(\'{var}\')\n')
    buff.write(f'{indent}return ret\n\n')


def _write_input(indent, buff, input, varname='input', typename='FuzzyInput'):
    """Create new input definition in body of generated module.

    Args:
        indent (str): Whitespace indicating indent level.
        buff (Filelike): Buffer being written to.
        input (FuzzyInput): FuzzyInput object to encode.
        varname (str,optional): Name to apply to variable while it is being configured; this does not need to be unique.
        typename(str,optional): The object typename for the definition. This should be either `FuzzyInput` or a subclass.
    """

    buff.write(f'{indent}{varname}={typename}("{input.name}",{input.minval},{input.maxval})\n')
    for _, c in input.curve_iter():

        if not isinstance(c, PiecewiseCurve):
            buff.write(f'{indent}curve={c.__class__.__name__}("{c.name}")\n')
            props = get_propdetails_for_obj(c)
            for pe in props:
                buff.write(f'{indent}curve.{pe.prop}={getattr(c,pe.prop)}\n')
        else:
            buff.write(f'{indent}segments=[]\n')
            for s in c.segments():
                buff.write(f'{indent}s={s.__class__.__name__}(Pt2D{s.lowpoint},Pt2D{s.highpoint})\n')
                for k, v in s.equation_args:
                    buff.write(f'{indent}s.{k}={v}\n')
                buff.write(f'{indent}segments.append(s)\n')

            buff.write(f'{indent}curve={c.__class__.__name__}("{c.name}",segments)\n')
        buff.write(f'{indent}{varname}.add_curve(curve)\n')


def _write_flset(indent, buff, fls, varname='fls'):
    """Write code to generate the contents of a fuzzylogic set within the generated module.

    Args:
        indent (str): Whitespace indicating indent level.
        buff (Filelike): Buffer being written to.
        fls (FuzzyLogicSet): The FuzzyLogicSet to embed in the generated module.
        varname (str,optional): The name to apply to the variable within the generated code.
    """

    buff.write(f'{indent}val_inputs = {{}}\n')
    for inp in fls.inputs:
        _write_input(indent, buff, inp)
        buff.write(f'{indent}val_inputs[input.name]=input\n')
    _write_result(indent, buff, fls.result)
    # buff.write(f'{indent}results = result\n')
    buff.write(f'{indent}{varname} = (val_inputs,result)\n')


def _write_result(indent, buff, result):
    """Create new result definition in body of generated module.

    Args:
        indent (str): Whitespace indicating indent level.
        buff (Filelike): Buffer being written to.
        result (FuzzyResult): FuzzyResult object to encode.
    """

    _write_input(indent, buff, result, 'result', 'FuzzyResult')


def _write_run_code(indent, buff, flsets):
    """Generate function for executing the encoded fuzzylogic.

    Args:
        indent (str): Whitespace indicating indent level.
        buff (Filelike): Buffer being written to.
        flsets (dict): Dict with FuzzyLogicSet for values, and their labels as keys.
    """

    buff.write(f'{indent}def get_implications(_flsets,inVals):\n')
    indent += INDENT_STEP
    for v in dict(**FuzzyRule.unary_op_map(), **FuzzyRule.binary_op_map(), **FuzzyRule.fn_map()).values():
        buff.write(f'{indent}{v.__name__}=FuzzyRule.{v.__name__}\n')
    buff.write(f'{indent}_impls={{}}\n')

    for name, fls in flsets.items():
        buff.write(f'{indent}try:\n')
        buff.write(f'{indent+INDENT_STEP}_inputs,_result =_flsets["{name}"]\n')
        buff.write(f'{indent+INDENT_STEP}_impls["{name}"]=')
        buff.write(f'{fls.rules[0].pythonlogic}\n')
        buff.write(f'{indent}except FuzzyNoValError as err:\n')
        buff.write(f'{indent + INDENT_STEP}_impls["{name}"]=err\n')
    # buff.write(f'{indent}for i in range(1,len(_impls)):\n')
    # buff.write(f'{indent+INDENT_STEP}_impls[0]+=_impls[i]\n')
    buff.write(f'{indent}return _impls\n\n')


def _write_combiners(indent, buff, combiners):
    """Write function to execute combiners on implications generated from executing embedded fuzzylogic.

    Args:
        indent (str): Whitespace indicating indent level.
        buff (Filelike): Buffer being written to.
        combiners (dict): A dictionary of dictionaries describing combiners as they are in a SIMPA settings file,
          with their labels as keys.
    """

    buff.write(f'{indent}def apply_combiners(_impls,addl_args=None):\n')
    indent += INDENT_STEP
    subdent = indent+INDENT_STEP

    buff.write(f'{indent}from math import acos,acosh,asin,asinh,atan,atan2,atanh,ceil,degrees,e,exp,floor,inf,log,log2,'
               f'log10,pi,radians,sin,sinh,sqrt,tan,tanh\n')
    buff.write(f'{indent}checknodata=FLCombiner.nodata_op\n')
    buff.write(f'{indent}max=FLCombiner.maxop\n')
    buff.write(f'{indent}min=FLCombiner.minop\n')
    buff.write(f'{indent}sum=FLCombiner.sumop\n')
    buff.write(f'{indent}product=FLCombiner.prodop\n')
    buff.write(f'{indent}gamma=FLCombiner.gammaop\n\n')
    buff.write(f'{indent}_ret={{}}\n')

    # find each unique crisp value
    unique_crisp = {}

    for name, combo in combiners.items():

        # write variables and defuzzifiers
        defuzz_dict = combo['defuzzOperators']
        def_defuzz = combo["defaultDefuzzOperator"]
        impl_names = FLCombiner.parse_expected(combo['combineStatement'])
        for n in impl_names:
            fuzop = defuzz_dict.get(n, def_defuzz)
            to_assign = f'{indent}{n}=_impls["{n}"].{fuzop}()\n'
            if unique_crisp.get(n, None) != to_assign:
                buff.write(to_assign)
            unique_crisp[n] = to_assign

        buff.write(f'{indent}try:\n')
        buff.write(f'{subdent}_ret["{name}"]={combo["combineStatement"]}\n')
        buff.write(f'{indent}except FuzzyNoValError:\n')
        buff.write(f'{subdent}_ret["{name}"]=NODATA_VAL\n')
    buff.write(f'{indent}return _ret\n\n')


def _write_nodata_mode(indent, buff, ndmethod, ndsubvalue):
    """Create function to encapsulate the logic chosen for handling encountered nodata values.

    Args:
        indent (str): Whitespace indicating indent level.
        buff (Filelike): Buffer being written to.
        ndmethod (str): Label indicating method to use for managing nodata values.
        ndsubvalue (float): The optional substitution value for nodata.
    """

    buff.write(f'{indent}def gen_nodata_sentinel():\n')
    indent += INDENT_STEP
    buff.write(f'{indent}# derived from Nodata method: {ndmethod}\n')
    buff.write(f'{indent}ret=NoDataSentinel()\n')
    buff.write(f'{indent}ret.ignore={ndmethod == "ignore"}\n')
    buff.write(f'{indent}ret.subVal={None if ndmethod != "substitute" else ndsubvalue}\n')
    buff.write(f'{indent}return ret\n\n')


def generate_embeddable(buff, infile, flimport='fuzzylogic'):
    """Generate code for use in an embeddable module suitable for running the provided fuzzylogic statements.

    Args:
        buff (filelike): The buffer to write to.
        infile (str): Path to a SIMPA project file (*.sijn) to load.
        flimport (str,optional): Custom name for the fuzzylogic package to use in the import statement.

    """

    settings = load_settings(infile)

    _write_header('', buff, flimport)
    # collect expected arguments and import rules
    # go through the sets and grab input names
    in_names = set()
    for fls in settings['fuzzyLogicSets'].values():
        fls.import_rules()

        for inp in fls.inputs:
            in_names.add(inp.name)

    _write_check('', buff, in_names)

    buff.write('def initialize():\n')
    buff.write(f'{INDENT_STEP}_flsets={{}}\n')
    for name, fls in settings['fuzzyLogicSets'].items():
        _write_flset(INDENT_STEP, buff, fls, f'_flsets["{name}"]')

    combo_names = [f'"{k}"' for k in settings['fuzzyLogicCombiners']]
    buff.write(f'{INDENT_STEP}return _flsets,[{", ".join(combo_names)}]\n\n')

    _write_nodata_mode('', buff, settings['noDataMethod'], settings['noDataSubValue'])

    _write_run_code('', buff, settings['fuzzyLogicSets'])
    _write_combiners('', buff, settings['fuzzyLogicCombiners'])
